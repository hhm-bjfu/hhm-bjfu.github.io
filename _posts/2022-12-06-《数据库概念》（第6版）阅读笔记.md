---
建立layout:	post
title:	《数据库系统概念》（第6版）阅读笔记
categories:	[Tech-Note]
---

[toc]

由于课程匆忙，故只细看1-7章 + （应对课设），后面有时间细看。

并且，为了当作提前预习，先在[蓝桥网](https://www.lanqiao.cn/courses/9)上练习mysql基本操作，相关笔记放在第0章。

黑皮书yyds！

<!-- more -->

## 第 0 章——蓝桥网练习

#### lab1 SQL介绍及安装

MySQL目前属于Oracle公司，由于其体积小、速度快、源码开放，逐渐成为中小型网站主流。

> 以下命令均在Ubuntu20.04 上运行

打开MySQL：`sudo service mysql start`

安装MySQL：

```sql
# 安装 MySQL 服务端、核心程序
sudo apt-get install mysql-server

# 安装 MySQL 客户端
sudo apt-get install mysql-client
layout:	post
title:	《英语魔法师之语法俱乐部》阅读笔记
date: 2022-12-11
categories:	[Read-Note]
# 测试
sudo netstat -tap | grep mysql
```

打开MySQL：

```sql
# 启动mysql服务
sudo service mysql start

# 使用root用户进行登录
sudo mysql -u root
```

查看数据库：`show dasabase;`

#### lab2 创建数据库并插入数据

连接数据库：`use <数据库名>u;`

连接数据库后查看表：`show tables;`

创建db并插入数据：

```sql
create database mysql_shiyan;
show databases;
use mysql_shiyan;
show tables; 
```

db只是一个框架，表才是实质内容。创建表例子如下：

```sql
create table employee (
	id int(10),
    name char(20),
    phone int(12)
);
create table department (
	dpt_name char(20);
    dpt_phone int(12);
);
show tables;
```

mysql常用数据类型如下：

![image](https://user-images.githubusercontent.com/88172940/207494356-9a270f65-3d8e-4d4f-9f4f-259c3dc2a6ba.png)

char和varchar区别：char长度固定，varchar长度不固定。

插入数据：

```sql
insert into employee(id, name, phone) values(01, 'Tom', 110110110); # 完整形态
insert into employee values (02, 'Jack', 119119119);
insert into employee(id, name) values(03, 'Rose');
```

#### lab3 SQL的约束

约束是一种限制，通过对表中行或者列的数据作出限制，确保表中数据的完整性和唯一性。

mysql中通常有以下几种约束：

* 主键 primary key，一行数据的唯一标识符，不能重复也不能为空。

```sql
dpt_name char(20) primary key, # 定义主键的一种方式
constraint dpt_pk primary key(dpt_name), # 定义主键的另一种方式，其中dpt_pk是自定义的名字
constraint proj_pk primary key(proj_num, proj_name), # 定义复合主键
```

* 默认值 default，插入为空时使用default。

```sql
people_num int(10) default 10;
```

* 唯一 unique，规定某列的每个值都是唯一的。

```sql
unique (phone), # 保证phone这列的每个值都是不相同的，否则会报错
```

* 外键 foreign key，外键确保数据完整性且表现表之间关系。

```sql
constraint emp_fk foreign key(in_dpt) references department(dpt_name);
```

* 非空 not null

删除数据库：`drop database mysql_shiyan;`

新建一个初始库，`vim MySQL-03-01.sql `

```sql
create database mysql_shiyan;

use mysql_shiyan;

create table department
(
	dpt_name char(20) not null,
    people_num int(10) default '10',
    constraint dpt_pk primary key(dpt_name)
);

create table employee
(
	id int(10) primary key,
    name char(20),
    age int(10),
    salary int(10) not null,
    phone int(12) not null,
    in_dpt char(20) not null,
    unique (phone),
    constraint emp_fk foreign key (in_dpt) references department(dpt_name)
);

create table project
(
	proj_num int(10) not null,
    proj_name char(20) not null,
    start_date date not null,
    end_date date default '2015-04-01',
    of_dpt char(20) references department(dpt_name),
   	constraint proj_pk primary key (proj_num, proj_name)
);
```

加载上面的sql文件：`source  /home/hhm/Code/lanqiaoTmp/MySQL-03-01.sql;`

即可得到一个新建的数据库。

#### 挑战1 搭建简易成绩管理系统数据库

`vim createStudent.sql`

`sudo service mysql start`

`mysql -u root`

```sql
create database gradesystem;
use gradesystem

create table student (
	sid int not null auto_increment,
    sname varchar(20) not null,
    gender varchar(10) not null,
    primary key(sid)
);

create table course (
	cid int not null auto_increment,
    cname varchar(20) not null,
    primary key(cid)
);

create table mark (
	mid int not null auto_increment,
    sid int not null,
    cid int not null,
    score int not null,
    primary key(mid),
    foreign key(sid) references student(sid),
    foreign key(cid) references course(cid)
);

insert into student(sid, sname, gender) values(1, 'Tom', 'male'), (2, 'Jack', 'male'), (3, 'Rose', 'female');
insert into course(cid, cname) values(1, 'math'), (2, 'physics'), (3, 'chemistry');
insert into mark(mid, sid, cid, score) values(1,1,1,80),(2,2,1,85),(3,3,1,90),(4,1,2,60),(5,2,2,90),(6,3,2,75),(7,1,3,95),(8,2,3,75),(9,3,3,85);
```

#### lab4 select 语句详解

其中MySQL-04-01.sql中内容如下：

```sql
create database mysql_shiyan;
use mysql_shiyan;

create table department
(
	dpt_name char(20) not null,
    people_num int(10) default '10',
    constraint dpt_pk primary key(dpt_name)
);

create table employee
(
	id int(10) primary key,
    name char(20),
    age int(10),
    salary int(10) not null,
    phone int(10) not null,
    in_dpt char(20) not null,
    unique (phone),
    constraint emp_fk foreign key (in_dpt) references department(dpt_name)
);

create table project
(
	proj_num int(10) not null,
    proj_name char(20) not null,
    start_date date not null,
    end_date date default '2015-04-01',
    of_dpt char(20) references department(dpt_name),
    constraint proj_pk primary key (proj_num, proj_name)
);
```

MySQL-04-02.sql内容如下：

```sql
# insert into department(dpt_name, people_num) values('部门', 人数);
INSERT INTO department(dpt_name,people_num) VALUES('dpt1',11);
INSERT INTO department(dpt_name,people_num) VALUES('dpt2',12);
INSERT INTO department(dpt_name,people_num) VALUES('dpt3',10);
INSERT INTO department(dpt_name,people_num) VALUES('dpt4',15);

#INSERT INTO employee(id,name,age,salary,phone,in_dpt) VALUES(\u7f16\u53f7,'\u540d\u5b57',\u5e74\u9f84,\u5de5\u8d44,\u7535\u8bdd,'\u90e8\u95e8');

INSERT INTO employee(id,name,age,salary,phone,in_dpt) VALUES(01,'Tom',26,2500,119119,'dpt4');
INSERT INTO employee(id,name,age,salary,phone,in_dpt) VALUES(02,'Jack',24,2500,120120,'dpt2');
INSERT INTO employee(id,name,age,salary,phone,in_dpt) VALUES(03,'Rose',22,2800,114114,'dpt3');
INSERT INTO employee(id,name,age,salary,phone,in_dpt) VALUES(04,'Jim',35,3000,100861,'dpt1');
INSERT INTO employee(id,name,age,salary,phone,in_dpt) VALUES(05,'Mary',21,3000,100101,'dpt2');
INSERT INTO employee(id,name,age,salary,phone,in_dpt) VALUES(06,'Alex',26,3000,123456,'dpt1');
INSERT INTO employee(id,name,age,salary,phone,in_dpt) VALUES(07,'Ken',27,3500,654321,'dpt1');
INSERT INTO employee(id,name,age,salary,phone,in_dpt) VALUES(08,'Rick',24,3500,987654,'dpt3');
INSERT INTO employee(id,name,age,salary,phone,in_dpt) VALUES(09,'Joe',31,3600,110129,'dpt2');
INSERT INTO employee(id,name,age,salary,phone,in_dpt) VALUES(10,'Mike',23,3400,110110,'dpt4');
INSERT INTO employee(id,name,salary,phone,in_dpt) VALUES(11,'Jobs',3600,019283,'dpt2');
INSERT INTO employee(id,name,salary,phone,in_dpt) VALUES(12,'Tony',3400,102938,'dpt3');






#INSERT INTO project(proj_num,proj_name,start_date,end_date,of_dpt) VALUES(\u7f16\u53f7,'\u5de5\u7a0b\u540d','\u5f00\u59cb\u65f6\u95f4','\u7ed3\u675f\u65f6\u95f4','\u90e8\u95e8\u540d');

INSERT INTO project(proj_num,proj_name,start_date,end_date,of_dpt) VALUES(01,'proj_a','2015-01-15','2015-01-31','dpt2');
INSERT INTO project(proj_num,proj_name,start_date,end_date,of_dpt) VALUES(02,'proj_b','2015-01-15','2015-02-15','dpt1');
INSERT INTO project(proj_num,proj_name,start_date,end_date,of_dpt) VALUES(03,'proj_c','2015-02-01','2015-03-01','dpt4');
INSERT INTO project(proj_num,proj_name,start_date,end_date,of_dpt) VALUES(04,'proj_d','2015-02-15','2015-04-01','dpt3');
INSERT INTO project(proj_num,proj_name,start_date,end_date,of_dpt) VALUES(05,'proj_e','2015-02-25','2015-03-01','dpt4');
INSERT INTO project(proj_num,proj_name,start_date,end_date,of_dpt) VALUES(06,'proj_f','2015-02-26','2015-03-01','dpt2');
```

select基本格式：`select 查询列 from 表名字 where 限制条件;`

where后面的限制条件可以分为以下几类：

* 数学符号

查询age>25:`select name, age from employee where age > 25;`

查询Mary员工的name，age，phone:`select name, age, phone from employee where name = 'Mary';`

* and和or

逻辑连接筛选条件。

`select name, age from employee where age < 25 or age > 30;`

`select name, age from employee where age > 25 and age < 30;`

* in和not in

类比python，代表在与不在。

`select name, age, phone, in_dpt from employee where in_dpt in ('dpt3', 'dpt4');`

`select name, age, phone, in_dpt from employee where in_dpt not in ('dpt3', 'dpt4');`

* 通配符

关键词`like`来实现模糊查询。

`_`表示未指定字符，`%`表示不定个未指定字符。

`select name, age, phone from employee where phone like '1101__';`

`select name, age, phone from employee where phone like 'J%';`

* 对结果进行排序

查询结果可以用order by来进行排序。

`select name, age, salary, phone from employee order by salary desc`

* SQL内置函数

`count`

`sum`

`avg`

`max`

`min`

求解salary中最大、最小值：

`select max(salary) as max_salary, min(salary) from employee;`

**其中as表示重命名**。

#### lab5 数据库及表的修改和删除

删除：`drop database test_01;`

重命名：`rename table table_1 to table_2;`

增加一列：`alter table employee add height int(4) default 170 after age;` // 新增加一列height，放在age列后面，使用`first`则是放在前面。

删除一列：`alter table employee drop height;`

改变某个值：`update employee set age = 21, salary = 3000 where name = 'Tom';`

#### lab6 其他基本操作

* 索引

索引相当于书的目录，可以帮助我们快速找到所需内容。

对某列建立索引有两种格式：

* `alter table employee add index idx_id (id); # 在employee表的id列上建立名为idx_id的索引，其中id为列名`

对比增加列操作可以看出，本质上索引就是多增加了一个**特殊的列**。

* `create index idx_name on employee (name) # 在employee表的name列中建立了名为idx_name的索引`

其中MySQL-06.sql文件如下：

```sql

CREATE DATABASE mysql_shiyan;

use mysql_shiyan;

CREATE TABLE department
(
  dpt_name   CHAR(20) NOT NULL,
  people_num INT(10) DEFAULT '10',
  CONSTRAINT dpt_pk PRIMARY KEY (dpt_name)
 );

CREATE TABLE employee
(
  id      INT(10) PRIMARY KEY,
  name    CHAR(20),
  age     INT(10),
  salary  INT(10) NOT NULL,
  phone   INT(12) NOT NULL,
  in_dpt  CHAR(20) NOT NULL,
  UNIQUE  (phone),
  CONSTRAINT emp_fk FOREIGN KEY (in_dpt) REFERENCES department(dpt_name)
 );
 
CREATE TABLE project
(
  proj_num   INT(10) NOT NULL,
  proj_name  CHAR(20) NOT NULL,
  start_date DATE NOT NULL,
  end_date   DATE DEFAULT '2015-04-01',
  of_dpt     CHAR(20) REFERENCES department(dpt_name),
  CONSTRAINT proj_pk PRIMARY KEY (proj_num,proj_name)
 );

CREATE TABLE table_1
(
l_1 INT(10) PRIMARY KEY,
l_2 INT(10),
l_3 INT(10)
 );



#INSERT INTO department(dpt_name,people_num) VALUES('\u90e8\u95e8',\u4eba\u6570);

INSERT INTO department(dpt_name,people_num) VALUES('dpt1',11);
INSERT INTO department(dpt_name,people_num) VALUES('dpt2',12);
INSERT INTO department(dpt_name,people_num) VALUES('dpt3',10);
INSERT INTO department(dpt_name,people_num) VALUES('dpt4',15);


#INSERT INTO employee(id,name,age,salary,phone,in_dpt) VALUES(\u7f16\u53f7,'\u540d\u5b57',\u5e74\u9f84,\u5de5\u8d44,\u7535\u8bdd,'\u90e8\u95e8');

INSERT INTO employee(id,name,age,salary,phone,in_dpt) VALUES(01,'Tom',26,2500,119119,'dpt4');
INSERT INTO employee(id,name,age,salary,phone,in_dpt) VALUES(02,'Jack',24,2500,120120,'dpt2');
INSERT INTO employee(id,name,salary,phone,in_dpt) VALUES(03,'Jobs',3600,019283,'dpt2');
INSERT INTO employee(id,name,salary,phone,in_dpt) VALUES(04,'Tony',3400,102938,'dpt3');
INSERT INTO employee(id,name,age,salary,phone,in_dpt) VALUES(05,'Rose',22,2800,114114,'dpt3');



#INSERT INTO project(proj_num,proj_name,start_date,end_date,of_dpt) VALUES(\u7f16\u53f7,'\u5de5\u7a0b\u540d','\u5f00\u59cb\u65f6\u95f4','\u7ed3\u675f\u65f6\u95f4','\u90e8\u95e8\u540d');

INSERT INTO project(proj_num,proj_name,start_date,end_date,of_dpt) VALUES(01,'proj_a','2015-01-15','2015-01-31','dpt2');
INSERT INTO project(proj_num,proj_name,start_date,end_date,of_dpt) VALUES(02,'proj_b','2015-01-15','2015-02-15','dpt1');
INSERT INTO project(proj_num,proj_name,start_date,end_date,of_dpt) VALUES(03,'proj_c','2015-02-01','2015-03-01','dpt4');
INSERT INTO project(proj_num,proj_name,start_date,end_date,of_dpt) VALUES(04,'proj_d','2015-02-15','2015-04-01','dpt3');
INSERT INTO project(proj_num,proj_name,start_date,end_date,of_dpt) VALUES(05,'proj_e','2015-02-25','2015-03-01','dpt4');
INSERT INTO project(proj_num,proj_name,start_date,end_date,of_dpt) VALUES(06,'proj_f','2015-02-26','2015-03-01','dpt2');
```

比如有一个用户表，它拥有用户名(username)和个人签名(note)两个字段。其中用户名具有唯一性，并且格式具有较强的限制，我们给用户名加上一个唯一索引；个性签名格式多变，而且允许不同用户使用重复的签名，不加任何索引。

这时候，如果你要查找某一用户，使用语句 `select * from user where username=?` 和 `select * from user where note=?` 性能是有很大差距的，对**建立了索引的用户名**进行条件查询会比**没有索引的个性签名**条件查询快几倍，在数据量大的时候，这个差距只会更大。

* 视图

视图格式：`create view 视图名(列1，列2, 列3) as select 列1, 列2, 列3 from 表名字;`

```sql
create view v_emp (v_name, v_age, v_phone) as select name, age, phone from employee;

# 查看视图
select * from v_emp;
```

* 导入

导入纯数据文件，以此完成快速导入大量数据。

导入：`load data infile '文件路径和文件名' into table 表名字;`

其中in.txt内容如下：

```sql
6	Alex	26	3000	123456	dpt1
7	Ken		27	3500	654321	dpt1
8	Rick	24	3500	987654	dpt3
9	Joe		31	3600	100129	dpt2
10	Mike	23	3400	110110	dpt1
11	Jim		35	3000	100861	dpt4
12	Mary	21	3000	100101	dpt2
```

由于导入导出大量数据都属于敏感操作，根据 mysql 的安全策略，导入导出的文件都必须在指定的路径下进行，在 mysql 终端中查看路径变量：`show variables like '%secure%';`

**导入的数据一定是用tab来分割的。**

* 导出

`select * into outfile '/var/lib/mysql-files/out.txt' from employee;`

* 备份

导出只是导出了数据，但是备份是将数据库结构也另存出来了。

备份整个数据库：`mysqldump -u root 数据库名 > 备份文件名;`

备份整个表：`mysqldump -u root 数据库名 表名字 > 备份文件名;`

**mysqldump 是一个备份工具，因此该命令是在终端中执行的，而不是在 mysql 交互环境下**

备份mysql_shiyan数据库，将其备份为bak.sql:

```sql
cd /var/lib/mysql
mysqldump -u root mysql_shiyan > bak.sql;
```



## 序

#### 书籍介绍

1-9章讲述数据库系统基本概念。

10-19章讨论数据库系统实现技术，包括存储技术、数据存取技术等。

20-23章主要讨论数据管理与应用的深入话题。

24-26章是一些高级话题。

27-30章讨论四大主流数据库，`PostgreSQL、Oracle、IBM DB2、Microsoft SQL Server`的实例研究。

相关课程网站：https://www.db-book.com/

![image-20221214110526914](/home/hhm/.config/Typora/typora-user-images/image-20221214110526914.png)

`What is New in The Seventh Edition`：描述第7版新添加的东西。

`Online book content`：提供每一章节的电子版，没什么用。

`Side`：提供每一章节幻灯片。

`Solutions to Practice Exercises`：**课后练习题的答案，nice！**

`Laboratory material`：实验室材料。

* `(New) Run SQL queries directly in your browser`：在线sql语句运行环境，预加载了大学数据库模式和示例数据。
* `Sample tables`：样品表。

需要注意，由于`Oracle`数据库不支持`time`类型，因此将`start_time`拆为了整数类型的`start_hr、start_min`。建议自己写时将DDL和示例数据文件修改。

**DDL(use this the first time)**

```sql
create table classroom
	(building		varchar(15),
	 room_number	varchar(7),
	 capacity		numeric(4,0),
	 primary key (building, room_number)
	);

create table department
	(dept_name		varchar(20), 
	 building		varchar(15), 
	 budget			numeric(12,2) check (budget > 0),
	 primary key (dept_name)
	);

create table course
	(course_id		varchar(8), 
	 title			varchar(50), 
	 dept_name		varchar(20),
	 credits		numeric(2,0) check (credits > 0),
	 primary key (course_id),
	 foreign key (dept_name) references department (dept_name)
		on delete set null
	);

create table instructor
	(ID			varchar(5), 
	 name			varchar(20) not null, 
	 dept_name		varchar(20), 
	 salary			numeric(8,2) check (salary > 29000),
	 primary key (ID),
	 foreign key (dept_name) references department (dept_name)
		on delete set null
	);

create table section
	(course_id		varchar(8), 
         sec_id			varchar(8),
	 semester		varchar(6)
		check (semester in ('Fall', 'Winter', 'Spring', 'Summer')), 
	 year			numeric(4,0) check (year > 1701 and year < 2100), 
	 building		varchar(15),
	 room_number		varchar(7),
	 time_slot_id		varchar(4),
	 primary key (course_id, sec_id, semester, year),
	 foreign key (course_id) references course (course_id)
		on delete cascade,
	 foreign key (building, room_number) references classroom (building, room_number)
		on delete set null
	);

create table teaches
	(ID			varchar(5), 
	 course_id		varchar(8),
	 sec_id			varchar(8), 
	 semester		varchar(6),
	 year			numeric(4,0),
	 primary key (ID, course_id, sec_id, semester, year),
	 foreign key (course_id, sec_id, semester, year) references section (course_id, sec_id, semester, year)
		on delete cascade,
	 foreign key (ID) references instructor (ID)
		on delete cascade
	);

create table student
	(ID			varchar(5), 
	 name			varchar(20) not null, 
	 dept_name		varchar(20), 
	 tot_cred		numeric(3,0) check (tot_cred >= 0),
	 primary key (ID),
	 foreign key (dept_name) references department (dept_name)
		on delete set null
	);
(use this if you wish to recreate the database after dropping existing tables)
create table takes
	(ID			varchar(5), 
	 course_id		varchar(8),
	 sec_id			varchar(8), 
	 semester		varchar(6),
	 year			numeric(4,0),
	 grade		        varchar(2),
	 primary key (ID, course_id, sec_id, semester, year),
	 foreign key (course_id, sec_id, semester, year) references section (course_id, sec_id, semester, year)
		on delete cascade,
	 foreign key (ID) references student (ID)
		on delete cascade
	);

create table advisor
	(s_ID			varchar(5),
	 i_ID			varchar(5),
	 primary key (s_ID),
	 foreign key (i_ID) references instructor (ID)
		on delete set null,
	 foreign key (s_ID) references student (ID)
		on delete cascade
	);

create table time_slot
	(time_slot_id		varchar(4),
	 day			varchar(1) check (day in ('M', 'T', 'W', 'R', 'F', 'S', 'U')),
	 start_time		time,
     end_time		time,
	 primary key (time_slot_id, day, start_time)
	);

create table prereq
	(course_id		varchar(8), 
	 prereq_id		varchar(8),
	 primary key (course_id, prereq_id),
	 foreign key (course_id) references course (course_id)
		on delete cascade,
	 foreign key (prereq_id) references course (course_id)
	);

```

**DDL with drop table(use this if you wish to recreate the database after dropping existing tables)**

```sql

drop table prereq;
drop table time_slot;
drop table advisor;
drop table takes;
drop table student;
drop table teaches;
drop table section;
drop table instructor;
drop table course;
drop table department;
drop table classroom;



create table classroom
	(building		varchar(15),
	 room_number		varchar(7),
	 capacity		numeric(4,0),
	 primary key (building, room_number)
	);

create table department
	(dept_name		varchar(20), 
	 building		varchar(15), 
	 budget		        numeric(12,2) check (budget > 0),
	 primary key (dept_name)
	);

create table course
	(course_id		varchar(8), 
	 title			varchar(50), 
	 dept_name		varchar(20),
	 credits		numeric(2,0) check (credits > 0),
	 primary key (course_id),
	 foreign key (dept_name) references department (dept_name)
		on delete set null
	);

create table instructor
	(ID			varchar(5), 
	 name			varchar(20) not null, 
	 dept_name		varchar(20), 
	 salary			numeric(8,2) check (salary > 29000),
	 primary key (ID),
	 foreign key (dept_name) references department (dept_name)
		on delete set null
	);

create table section
	(course_id		varchar(8), 
         sec_id			varchar(8),
	 semester		varchar(6)
		check (semester in ('Fall', 'Winter', 'Spring', 'Summer')), 
	 year			numeric(4,0) check (year > 1701 and year < 2100), 
	 building		varchar(15),
	 room_number		varchar(7),
	 time_slot_id		varchar(4),
	 primary key (course_id, sec_id, semester, year),
	 foreign key (course_id) references course (course_id)
		on delete cascade,
	 foreign key (building, room_number) references classroom (building, room_number)
		on delete set null
	);

create table teaches
	(ID			varchar(5), 
	 course_id		varchar(8),
	 sec_id			varchar(8), 
	 semester		varchar(6),
	 year			numeric(4,0),
	 primary key (ID, course_id, sec_id, semester, year),
	 foreign key (course_id, sec_id, semester, year) references section (course_id, sec_id, semester, year)
		on delete cascade,
	 foreign key (ID) references instructor (ID)
		on delete cascade
	);

create table student
	(ID			varchar(5), 
	 name			varchar(20) not null, 
	 dept_name		varchar(20), 
	 tot_cred		numeric(3,0) check (tot_cred >= 0),
	 primary key (ID),
	 foreign key (dept_name) references department (dept_name)
		on delete set null
	);

create table takes
	(ID			varchar(5), 
	 course_id		varchar(8),
	 sec_id			varchar(8), 
	 semester		varchar(6),
	 year			numeric(4,0),
	 grade		        varchar(2),
	 primary key (ID, course_id, sec_id, semester, year),
	 foreign key (course_id, sec_id, semester, year) references section (course_id, sec_id, semester, year)
		on delete cascade,
	 foreign key (ID) references student (ID)
		on delete cascade
	);

create table advisor
	(s_ID			varchar(5),
	 i_ID			varchar(5),
	 primary key (s_ID),
	 foreign key (i_ID) references instructor (ID)
		on delete set null,
	 foreign key (s_ID) references student (ID)
		on delete cascade
	);

create table time_slot
	(time_slot_id		varchar(4),
	 day			varchar(1),
	 start_hr		numeric(2) check (start_hr >= 0 and start_hr < 24),
	 start_min		numeric(2) check (start_min >= 0 and start_min < 60),
	 end_hr			numeric(2) check (end_hr >= 0 and end_hr < 24),
	 end_min		numeric(2) check (end_min >= 0 and end_min < 60),
	 primary key (time_slot_id, day, start_hr, start_min)
	);

create table prereq
	(course_id		varchar(8), 
	 prereq_id		varchar(8),
	 primary key (course_id, prereq_id),
	 foreign key (course_id) references course (course_id)
		on delete cascade,
	 foreign key (prereq_id) references course (course_id)
	);

```

`SQL code for creating small relations`：创建小关系数据表。其中`smallRelationsInsertFile.sql`包含了与附录A完全匹配的数据。

**smallRelationsInsertFile.sql**

```sql
delete from prereq;
delete from time_slot;
delete from advisor;
delete from takes;
delete from student;
delete from teaches;
delete from section;
delete from instructor;
delete from course;
delete from department;
delete from classroom;
insert into classroom values ('Packard', '101', '500');
insert into classroom values ('Painter', '514', '10');
insert into classroom values ('Taylor', '3128', '70');
insert into classroom values ('Watson', '100', '30');
insert into classroom values ('Watson', '120', '50');
insert into department values ('Biology', 'Watson', '90000');
insert into department values ('Comp. Sci.', 'Taylor', '100000');
insert into department values ('Elec. Eng.', 'Taylor', '85000');
insert into department values ('Finance', 'Painter', '120000');
insert into department values ('History', 'Painter', '50000');
insert into department values ('Music', 'Packard', '80000');
insert into department values ('Physics', 'Watson', '70000');
insert into course values ('BIO-101', 'Intro. to Biology', 'Biology', '4');
insert into course values ('BIO-301', 'Genetics', 'Biology', '4');
insert into course values ('BIO-399', 'Computational Biology', 'Biology', '3');
insert into course values ('CS-101', 'Intro. to Computer Science', 'Comp. Sci.', '4');
insert into course values ('CS-190', 'Game Design', 'Comp. Sci.', '4');
insert into course values ('CS-315', 'Robotics', 'Comp. Sci.', '3');
insert into course values ('CS-319', 'Image Processing', 'Comp. Sci.', '3');
insert into course values ('CS-347', 'Database System Concepts', 'Comp. Sci.', '3');
insert into course values ('EE-181', 'Intro. to Digital Systems', 'Elec. Eng.', '3');
insert into course values ('FIN-201', 'Investment Banking', 'Finance', '3');
insert into course values ('HIS-351', 'World History', 'History', '3');
insert into course values ('MU-199', 'Music Video Production', 'Music', '3');
insert into course values ('PHY-101', 'Physical Principles', 'Physics', '4');
insert into instructor values ('10101', 'Srinivasan', 'Comp. Sci.', '65000');
insert into instructor values ('12121', 'Wu', 'Finance', '90000');
insert into instructor values ('15151', 'Mozart', 'Music', '40000');
insert into instructor values ('22222', 'Einstein', 'Physics', '95000');
insert into instructor values ('32343', 'El Said', 'History', '60000');
insert into instructor values ('33456', 'Gold', 'Physics', '87000');
insert into instructor values ('45565', 'Katz', 'Comp. Sci.', '75000');
insert into instructor values ('58583', 'Califieri', 'History', '62000');
insert into instructor values ('76543', 'Singh', 'Finance', '80000');
insert into instructor values ('76766', 'Crick', 'Biology', '72000');
insert into instructor values ('83821', 'Brandt', 'Comp. Sci.', '92000');
insert into instructor values ('98345', 'Kim', 'Elec. Eng.', '80000');
insert into section values ('BIO-101', '1', 'Summer', '2017', 'Painter', '514', 'B');
insert into section values ('BIO-301', '1', 'Summer', '2018', 'Painter', '514', 'A');
insert into section values ('CS-101', '1', 'Fall', '2017', 'Packard', '101', 'H');
insert into section values ('CS-101', '1', 'Spring', '2018', 'Packard', '101', 'F');
insert into section values ('CS-190', '1', 'Spring', '2017', 'Taylor', '3128', 'E');
insert into section values ('CS-190', '2', 'Spring', '2017', 'Taylor', '3128', 'A');
insert into section values ('CS-315', '1', 'Spring', '2018', 'Watson', '120', 'D');
insert into section values ('CS-319', '1', 'Spring', '2018', 'Watson', '100', 'B');
insert into section values ('CS-319', '2', 'Spring', '2018', 'Taylor', '3128', 'C');
insert into section values ('CS-347', '1', 'Fall', '2017', 'Taylor', '3128', 'A');
insert into section values ('EE-181', '1', 'Spring', '2017', 'Taylor', '3128', 'C');
insert into section values ('FIN-201', '1', 'Spring', '2018', 'Packard', '101', 'B');
insert into section values ('HIS-351', '1', 'Spring', '2018', 'Painter', '514', 'C');
insert into section values ('MU-199', '1', 'Spring', '2018', 'Packard', '101', 'D');
insert into section values ('PHY-101', '1', 'Fall', '2017', 'Watson', '100', 'A');
insert into teaches values ('10101', 'CS-101', '1', 'Fall', '2017');
insert into teaches values ('10101', 'CS-315', '1', 'Spring', '2018');
insert into teaches values ('10101', 'CS-347', '1', 'Fall', '2017');
insert into teaches values ('12121', 'FIN-201', '1', 'Spring', '2018');
insert into teaches values ('15151', 'MU-199', '1', 'Spring', '2018');
insert into teaches values ('22222', 'PHY-101', '1', 'Fall', '2017');
insert into teaches values ('32343', 'HIS-351', '1', 'Spring', '2018');
insert into teaches values ('45565', 'CS-101', '1', 'Spring', '2018');
insert into teaches values ('45565', 'CS-319', '1', 'Spring', '2018');
insert into teaches values ('76766', 'BIO-101', '1', 'Summer', '2017');
insert into teaches values ('76766', 'BIO-301', '1', 'Summer', '2018');
insert into teaches values ('83821', 'CS-190', '1', 'Spring', '2017');
insert into teaches values ('83821', 'CS-190', '2', 'Spring', '2017');
insert into teaches values ('83821', 'CS-319', '2', 'Spring', '2018');
insert into teaches values ('98345', 'EE-181', '1', 'Spring', '2017');
insert into student values ('00128', 'Zhang', 'Comp. Sci.', '102');
insert into student values ('12345', 'Shankar', 'Comp. Sci.', '32');
insert into student values ('19991', 'Brandt', 'History', '80');
insert into student values ('23121', 'Chavez', 'Finance', '110');
insert into student values ('44553', 'Peltier', 'Physics', '56');
insert into student values ('45678', 'Levy', 'Physics', '46');
insert into student values ('54321', 'Williams', 'Comp. Sci.', '54');
insert into student values ('55739', 'Sanchez', 'Music', '38');
insert into student values ('70557', 'Snow', 'Physics', '0');
insert into student values ('76543', 'Brown', 'Comp. Sci.', '58');
insert into student values ('76653', 'Aoi', 'Elec. Eng.', '60');
insert into student values ('98765', 'Bourikas', 'Elec. Eng.', '98');
insert into student values ('98988', 'Tanaka', 'Biology', '120');
insert into takes values ('00128', 'CS-101', '1', 'Fall', '2017', 'A');
insert into takes values ('00128', 'CS-347', '1', 'Fall', '2017', 'A-');
insert into takes values ('12345', 'CS-101', '1', 'Fall', '2017', 'C');
insert into takes values ('12345', 'CS-190', '2', 'Spring', '2017', 'A');
insert into takes values ('12345', 'CS-315', '1', 'Spring', '2018', 'A');
insert into takes values ('12345', 'CS-347', '1', 'Fall', '2017', 'A');
insert into takes values ('19991', 'HIS-351', '1', 'Spring', '2018', 'B');
insert into takes values ('23121', 'FIN-201', '1', 'Spring', '2018', 'C+');
insert into takes values ('44553', 'PHY-101', '1', 'Fall', '2017', 'B-');
insert into takes values ('45678', 'CS-101', '1', 'Fall', '2017', 'F');
insert into takes values ('45678', 'CS-101', '1', 'Spring', '2018', 'B+');
insert into takes values ('45678', 'CS-319', '1', 'Spring', '2018', 'B');
insert into takes values ('54321', 'CS-101', '1', 'Fall', '2017', 'A-');
insert into takes values ('54321', 'CS-190', '2', 'Spring', '2017', 'B+');
insert into takes values ('55739', 'MU-199', '1', 'Spring', '2018', 'A-');
insert into takes values ('76543', 'CS-101', '1', 'Fall', '2017', 'A');
insert into takes values ('76543', 'CS-319', '2', 'Spring', '2018', 'A');
insert into takes values ('76653', 'EE-181', '1', 'Spring', '2017', 'C');
insert into takes values ('98765', 'CS-101', '1', 'Fall', '2017', 'C-');
insert into takes values ('98765', 'CS-315', '1', 'Spring', '2018', 'B');
insert into takes values ('98988', 'BIO-101', '1', 'Summer', '2017', 'A');
insert into takes values ('98988', 'BIO-301', '1', 'Summer', '2018', null);
insert into advisor values ('00128', '45565');
insert into advisor values ('12345', '10101');
insert into advisor values ('23121', '76543');
insert into advisor values ('44553', '22222');
insert into advisor values ('45678', '22222');
insert into advisor values ('76543', '45565');
insert into advisor values ('76653', '98345');
insert into advisor values ('98765', '98345');
insert into advisor values ('98988', '76766');
insert into time_slot values ('A', 'M', '8', '0', '8', '50');
insert into time_slot values ('A', 'W', '8', '0', '8', '50');
insert into time_slot values ('A', 'F', '8', '0', '8', '50');
insert into time_slot values ('B', 'M', '9', '0', '9', '50');
insert into time_slot values ('B', 'W', '9', '0', '9', '50');
insert into time_slot values ('B', 'F', '9', '0', '9', '50');
insert into time_slot values ('C', 'M', '11', '0', '11', '50');
insert into time_slot values ('C', 'W', '11', '0', '11', '50');
insert into time_slot values ('C', 'F', '11', '0', '11', '50');
insert into time_slot values ('D', 'M', '13', '0', '13', '50');
insert into time_slot values ('D', 'W', '13', '0', '13', '50');
insert into time_slot values ('D', 'F', '13', '0', '13', '50');
insert into time_slot values ('E', 'T', '10', '30', '11', '45 ');
insert into time_slot values ('E', 'R', '10', '30', '11', '45 ');
insert into time_slot values ('F', 'T', '14', '30', '15', '45 ');
insert into time_slot values ('F', 'R', '14', '30', '15', '45 ');
insert into time_slot values ('G', 'M', '16', '0', '16', '50');
insert into time_slot values ('G', 'W', '16', '0', '16', '50');
insert into time_slot values ('G', 'F', '16', '0', '16', '50');
insert into time_slot values ('H', 'W', '10', '0', '12', '30');
insert into prereq values ('BIO-301', 'BIO-101');
insert into prereq values ('BIO-399', 'BIO-101');
insert into prereq values ('CS-190', 'CS-101');
insert into prereq values ('CS-315', 'CS-101');
insert into prereq values ('CS-319', 'CS-101');
insert into prereq values ('CS-347', 'CS-101');
insert into prereq values ('EE-181', 'PHY-101');
```

`SQL code for creating large relations`：更加真实，也更大。

```sql
详见github
```

`tableGen.java`：生成上述的大数据文件。

```java
import java.util.Scanner;
import java.io.*;
import java.util.Random;
import java.text.DecimalFormat;
public class tableGen {
  private static int maxClassroom = 100, maxStudent = 4000, maxDepartment = 50, 
    maxRoom = 1000, maxCourse = 1000, maxSection = 2000, maxAdvisor = 4000,
    maxInstructor = 1000, maxTeaches = 5000, maxTakes= 40000, maxPrereq =  1000;
  private static int maxBuilding = 100, maxName = 4200, maxDept = 100, maxTitle = 1000;
  private static double maxSalary = 100000.0;
  private static double maxBudget = 999999.0;
  private static int maxID = 99999;
  private static Random rnd = new Random();
  private static String[] buildingArray = new String[maxBuilding];
  private static String[] nameArray = new String[maxName];
  private static String[] deptNameArray = new String[maxDept];
  private static String[] titleArray = new String[maxTitle];
  private static Boolean[] teachesArray = new Boolean[maxSection];
  private static int[] nextCourseSection = new int[1000]; // starts at 0
  private static DecimalFormat moneyFormat = new DecimalFormat("0.00");
  
  //primary keys
  // classroom
  private static String[] classroomBuilding = new String[maxClassroom];
  private static int[] classroomRoom = new int[maxRoom];
  // department
  private static String[] departmentDeptName = new String[maxDepartment];
  // course
  private static int[] courseCourseID = new int[maxCourse];
  // store course dept for integrity check
  private static String[] courseDept = new String[maxCourse];
  // instructor
  private static int[] instructorID = new int[maxInstructor];
  // store instructor dept for integrity check
  private static String[] instructorDept = new String[maxInstructor];
  // section
  private static int[] sectionCourseID = new int[maxSection];
  private static int[] sectionSectionID = new int[maxSection];
  private static String[] sectionSemester = new String[maxSection];
  private static int[] sectionYear = new int[maxSection];
  // teaches
  private static int[] teachesID = new int[maxTeaches];
  private static int[] teachesCourseID = new int[maxTeaches];
  private static int[] teachesSectionID = new int[maxTeaches];
  private static String[] teachesSemester = new String[maxSection];
  private static int[] teachesYear = new int[maxSection];
  // student
  private static int[] studentID = new int[maxStudent];
  // takes
  private static int[] takesID = new int[maxTakes];
  private static int[] takesCourseID = new int[maxTakes];
  private static int[] takesSectionID = new int[maxTakes];
  private static String[] takesSemester = new String[maxTakes];
  private static int[] takesYear = new int[maxTakes];
  // advisor 
  private static int[] advisorID = new int[maxAdvisor];
  // time slot is defined statically
  // prereq
  private static int[] prereqCourseID = new int[maxPrereq];
  private static int[] prereqPrereqID = new int[maxPrereq];
    
  private static String squote(int val) {
	return ("'"+val+"'");
  }
  private static String squote(String text) {
	return ("'"+text+"'");
  }
  private static Scanner openFile(String fileName) {
    Scanner in = null;
    try {
      in = new Scanner(new FileInputStream (fileName));
    }
    catch(FileNotFoundException e) {
      System.out.println ("Could not open the file");
      System.exit (0);
    }
    return in;
  }
  private static PrintWriter outputFile(String fileName) {
    PrintWriter out = null;
    try {
      out = new PrintWriter (new FileOutputStream (fileName));
    }
    catch (FileNotFoundException e) {
      System.out.println ("Could not open the file");
      System.exit (0);
    }
    return out;
  }
  private static void fillArrays() {
    int i;
    // fill buildingArray
    Scanner in = openFile("buildingNames");
    i = 0;
    while (in.hasNext() && i < maxBuilding) {
      buildingArray[i++] = in.nextLine();
    }
    if (i < maxBuilding) maxBuilding = i;
    in.close();
    // fill nameArray
    in = openFile("personNames");
    i = 0;
    while (in.hasNext() && i < maxName) {
      nameArray[i++] = in.nextLine();
    }
    if (i < maxName) maxName = i;
    in.close();
    // fill deptNameArray
    in = openFile("deptNames");
    i = 0;
    while (in.hasNext() && i < maxDept) {
      deptNameArray[i++] = in.nextLine();
    }
    if (i < maxDept) maxDept = i;
    in.close();
    // fill titleArray
    in = openFile("courseTitles");
    i = 0;
    while (in.hasNext() && i < maxTitle) {
      titleArray[i++] = in.nextLine();
    }
    if (i < maxTitle) maxTitle= i;
    in.close();
  }
  private static String getBuilding() {
    // building char(15)
    return buildingArray[rnd.nextInt(maxBuilding)];
  }
  private static int getRoom() {
    // room_no char(7)
    return rnd.nextInt(maxRoom); // stick with 3 digit rooms
  }
  private static int getCapacity() {
    // capacity numeric(4,0)
    // we'll use 226 as max and bias it towards small rooms
    int i = rnd.nextInt(16);
    return 10 + rnd.nextInt(1+i*i); 
  }
  private static String getBudget() {
    // budget numeric(12,2)
    return moneyFormat.format(maxBudget*rnd.nextFloat());
  }  
  private static String getTitle() {
    // title char(50)
    return titleArray[rnd.nextInt(maxTitle)];
  }
  private static int getCredits() {
    // credits numeric(2,0)
    return rnd.nextBoolean() ? 3 : 4;
  }
  private static int getID() {
    // ID numeric(9,0)
    return rnd.nextInt(maxID+1);
  }
  private static String getName() {
    // name char(20)
    return nameArray[rnd.nextInt(maxName)];
  }
  private static String getDeptName() {
    // dept_name char(20)
    return deptNameArray[rnd.nextInt(maxDept)];
  }
  private static String getSalary() {
    // salary numeric(8,2)
    return moneyFormat.format(29000 + maxSalary*rnd.nextFloat());
  }
  private static int getCourseID() {
    // course_id char(8)
    // we'll have courses numbered 100 - 999
    return 101 + rnd.nextInt(899);
  }
  private static int getSecID(int courseID) {
    // sec_id char(8)
    // first section is section 1, then 2, by course number independent of year
    return ++nextCourseSection[courseID];
  }
  private static String getSemester() {
    // semester char(6) check semester in ('Fall', 'Winter', 'Spring', 'Summer')
    return rnd.nextBoolean() ? "Fall" : "Spring";
  }
  private static int getYear() {
    // year numeric(4,0) check (year > 1759 and year < 2100)
    // stick to 2001 through 2010
    return 2001 + rnd.nextInt(10);
  }
  private static int getTotCred() {
    // tot_cred numeric(3,0)
    return rnd.nextInt(130);
  }
  private static String getGrade() {
    // grade char(2)
    int pM = rnd.nextInt(3);
    int lG = rnd.nextInt(3); // just A, B, C
    String x;
    if (pM == 0) x = "-";
    else if (pM == 1) x = " "; 
    else x = "+";
    char y = (char) ((int)'A' + lG);
    return y + x;
  }
  private static String getTimeSlot() {
    // time_slot_id char(4)
    // this table is fixed with slots A through P
    char x = (char) ((int)'A' + rnd.nextInt(16));
    return "" + x;
  }
  public static void main(String[] args) { 
    int classroom = 30;
    int department = 20;
    int course = 200;
    int instructor = 50;
    int section = 100;
    int teaches = 100;
    int student = 2000;
    int takes = 30000;
    int advisor = 1000;
    int timeSlot = 10;
    int prereq = 100;
    int i = 0, j = 0, r = 0, c = 0, x = 0, y = 0;
    boolean tryValue = true;
    String b = "", d = "", s = "";
    fillArrays();
    // fill classroom
    PrintWriter out = outputFile("largeRelationsInsertFile.sql");
    out.println("delete from prereq;");
    out.println("delete from time_slot;");
    out.println("delete from advisor;");
    out.println("delete from takes;");
    out.println("delete from student;");
    out.println("delete from teaches;");
    out.println("delete from section;");
    out.println("delete from instructor;");
    out.println("delete from course;");
    out.println("delete from department;");
    out.println("delete from classroom;");
    out.println("insert into time_slot values ( 'A', 'M', 8, 0, 8, 50);");
    out.println("insert into time_slot values ( 'A', 'W', 8, 0, 8, 50);");
    out.println("insert into time_slot values ( 'A', 'F', 8, 0, 8, 50);");
    out.println("insert into time_slot values ( 'B', 'M', 9, 0, 9, 50);");
    out.println("insert into time_slot values ( 'B', 'W', 9, 0, 9, 50);");
    out.println("insert into time_slot values ( 'B', 'F', 9, 0, 9, 50);");
    out.println("insert into time_slot values ( 'C', 'M', 11, 0, 11, 50);");
    out.println("insert into time_slot values ( 'C', 'W', 11, 0, 11, 50);");
    out.println("insert into time_slot values ( 'C', 'F', 11, 0, 11, 50);");
    out.println("insert into time_slot values ( 'D', 'M', 13, 0, 13, 50);");
    out.println("insert into time_slot values ( 'D', 'W', 13, 0, 13, 50);");
    out.println("insert into time_slot values ( 'D', 'F', 13, 0, 13, 50);");
    out.println("insert into time_slot values ( 'E', 'T', 10, 30, 11, 45);");
    out.println("insert into time_slot values ( 'E', 'R', 10, 30, 11, 45);");
    out.println("insert into time_slot values ( 'F', 'T', 14, 30, 15, 45);");
    out.println("insert into time_slot values ( 'F', 'R', 14, 30, 15, 45);");
    out.println("insert into time_slot values ( 'G', 'M', 16, 0, 16, 50);");
    out.println("insert into time_slot values ( 'G', 'W', 16, 0, 16, 50);");
    out.println("insert into time_slot values ( 'G', 'F', 16, 0, 16, 50);");
    out.println("insert into time_slot values ( 'H', 'W', 10, 0, 12, 30);");


    // PrintWriter out = outputFile("classroom.txt");
    for (i = 0; i < classroom; i++) {
      tryValue = true;
      while (tryValue) {
        b = getBuilding();
        r = getRoom();
        tryValue = false;
        for (j = 0; j < i; j++) {
          if (b.equals(classroomBuilding[j]) && r == classroomRoom[j]) tryValue = true;
        }
      }
      classroomBuilding[i] = b;
      classroomRoom[i] = r;
      s = squote(b) + ", " + r + ", " + getCapacity();
      out.println ("insert into classroom values(" + s +");");
    }
    // out.close();   
    // fill department
    // out = outputFile("department.txt");
    for (i = 0; i < department; i++) {
      tryValue = true;
      while (tryValue) {
        d = getDeptName();
        tryValue = false;
        for (j = 0; j < i; j++) {
          if (d.equals(departmentDeptName[j])) tryValue = true;
        }
      }
      departmentDeptName[i] =  d;
      s = squote(d) + ", " + squote(getBuilding()) + ", " + getBudget();
      // out.println (s);
      out.println ("insert into department values(" + s +");");
    }
    // out.close();      
    // fill course
    // out = outputFile("course.txt");
    for (i = 0; i < course; i++) {
      tryValue = true;
      while (tryValue) {
        c = getCourseID();
        tryValue = false;
        for (j = 0; j < i; j++) {
          if (c == courseCourseID[j]) tryValue = true;
        }
      }
      courseCourseID[i] = c;
      courseDept[c]=departmentDeptName[rnd.nextInt(department)];
      s = squote(c) + ", " + squote(getTitle()) + ", " + squote(courseDept[c])
          + ", " + getCredits();
      // out.println (s);
      out.println ("insert into course values(" + s +");");
    }
    // out.close();      
    // fill instructor
    // out = outputFile("instructor.txt");
    for (i = 0; i < instructor; i++) {
      tryValue = true;
      while (tryValue) { 
        c = getID();
        tryValue = false;
        for (j = 0; j < i; j++) {
          if (c == instructorID[j]) tryValue = true;
        }
      }
      instructorID[i] = c;
      instructorDept[i]=departmentDeptName[rnd.nextInt(department)];
      s = squote(c) + ", " + squote(getName()) + ", " + squote(instructorDept[i] )
        + ", " + getSalary();
      // out.println (s);
      out.println ("insert into instructor values(" + s +");");
    }
    // out.close();      
    // fill section
    // out = outputFile("section.txt");
    for (i = 0; i < section; i++) {
      c = courseCourseID[rnd.nextInt(course)];
      r = getSecID(c);
      j = rnd.nextInt(classroom);
      sectionCourseID[i] = c;
      sectionSectionID[i] = r;
      b = getSemester();
      sectionSemester[i] = b;
      x = getYear();
      sectionYear[i] = x;
      s = squote(c)  + ", " + squote(r) + ", " + squote(b) + ", " + x +
        ", " + squote(classroomBuilding[j]) + ", " + squote(classroomRoom[j]) + ", " + squote(getTimeSlot());
      //out.println (s);
      out.println ("insert into section values(" + s +");");
    }
    // out.close();      
    // fill teaches
    // out = outputFile("teaches.txt");
    for (i = 0; i < maxSection; i++) teachesArray[i] = false;
    for (i = 0; i < teaches; i++) {
      tryValue = true;
      while (tryValue) {
        j = rnd.nextInt(section);
        tryValue = teachesArray[j];
      }
      teachesArray[j] = true;
      c = sectionCourseID[j];
      r = sectionSectionID[j];
      b = sectionSemester[j];
      x = sectionYear[j];
      //  insist that instructor be in same department as the course being taught
      int chosenInstructor = -1;
      for (y = 0; y < instructor; y++) {
        if (instructorDept[y] == courseDept[c]) {
          if (chosenInstructor == -1) chosenInstructor = y;
          else if (rnd.nextInt(10) > 1) chosenInstructor = y;
        }
      }
      y = chosenInstructor == -1 ? rnd.nextInt(instructor) : chosenInstructor;
      if (instructorDept[y] == courseDept[c]) System.out.println("teaching outside dept: " + 
           y + " " + c);
      s = squote(instructorID[y]) + ", " + squote(c) + ", " + squote(r) + ", " + squote(b) + ", " + x;
      // out.println (s);
      out.println ("insert into teaches values(" + s +");");
    }
    // out.close();      
    // fill student
    // out = outputFile("student.txt");
    for (i = 0; i < student; i++) {
      tryValue = true;
      while (tryValue) {
        c = getID();
        tryValue = false;
        for (j = 0; j < i; j++) {
          if (c == studentID[j]) tryValue = true;
        }
      }
      studentID[i] = c;
      s = squote(c) + ", " + squote(getName()) + ", " + squote(departmentDeptName[rnd.nextInt(department)])
        + ", " + getTotCred();
      // out.println (s);
      out.println ("insert into student values(" + s +");");

    }
    // out.close();     
    // fill takes
    // out = outputFile("takes.txt");
    for (i = 0; i < takes; i++) {
      tryValue = true;
      while (tryValue) {
        j = rnd.nextInt(student);
        x = studentID[j];
        j = rnd.nextInt(section);
        c = sectionCourseID[j];
        r = sectionSectionID[j];
        b = sectionSemester[j];
        y = sectionYear[j];
        tryValue = false;
        for (j = 0; j < i; j++) {
          if (x == takesID[j] && c == takesCourseID[j] && r == takesSectionID[j]) 
            tryValue = true;
        }
      }
      takesID[i] = x;
      takesCourseID[i] = c;
      takesSectionID[i] = r;
      takesSemester[i] = b;
      takesYear[i] = y;
      s = squote(x) + ", " + squote(c) + ", " + squote(r) + ", " + squote(b) + ", " + y + ", " + squote(getGrade());
      // out.println (s);
      out.println ("insert into takes values(" + s +");");
    }
    //out.close();     
    // fill advisor
    //out = outputFile("advisor.txt");
    for (i = 0; i < student; i++) {
      s = squote(studentID[i]) + ", " + squote(instructorID[rnd.nextInt(instructor)]) ;
      // out.println (s);
      out.println ("insert into advisor values(" + s +");");
    }
    // out.close();      
    // fill prereq
    // out = outputFile("prereq.txt");
    for (i = 0; i < prereq; i++) {
      s = squote(courseCourseID[rnd.nextInt(course)]) + ", " + squote(courseCourseID[rnd.nextInt(course)]);
      // out.println (s);
      out.println ("insert into prereq values(" + s +");");
    }
    out.close();   
  }
}
```

#### 书中lab

书中的lab都是以大学企业为中心。

* 1、访问数据库

* 2、xxx等

以上lab是没有答案的。

#### 书中Projects

* 1、Retailer database(2010)
* 等

也许可以在网络上找到答案。

#### Ubuntu20.04 安装配置phpMyAdmin

https://www.gingerdoc.com/tutorials/how-to-install-and-secure-phpmyadmin-on-ubuntu-20-04

而后打开：http://localhost/phpmyadmin/index.php

命令行采用密码登录：`sudo mysql -u root -p`

## 第 1 章——引言

#### 数据视图

数据库管理系统（database management system DBMS），由数据集合和程序组成，简称数据库。

在DBMS出现之前，多采用永久记录的文件处理系统，手工进行更新和同步。

使用以下几个层次来对用户屏蔽复杂性：

* 物理层physical level：实际且负责的底层数据结构。
* 逻辑层logical level：描述存储什么数据及关系。
* 视图层view level：只描述db的某个部分。

实例instance：特定时刻的db，类比为某一时刻变量的值。

模式schema：db的总体设计，类比为变量声明。

#### 数据库语言

数据库语言通常分为以下两种，通常语言两者兼具。

* 数据定义语言data-definition language DDL。
* 数据操纵语言data-manipulation language DML。

#### 关系数据库

关系数据库基于关系模型，使用一系列表来表达数据和这些数据之间的联系。

**来自应用程序的数据库访问**

SQL不支持诸如从用户那里输入、输出到显示器，以及网络通信等，这种计算和动作可以使用一种宿主语言来写，比如Java或者C++，在其中使用嵌入式SQL查询来访问数据库中的数据，有两种途径实现：

* 数据库提供应用程序接口（过程集），它将DML和DDL语句发给数据库，再返回结果。C语言一起使用的开放数据库连接（**ODBC**），Java数据库连接（**JDBC**）标准为Java提供相应特性。
* 拓展宿主语言的语法，在宿主语言中嵌入SQL语句，使用某个特殊字符作为DML调用的开始，通过预处理器将DML转变成宿主语言的过程调用。

#### 数据库的设计

实体-联系E-R模型，其中实体通过属性（列）来描述。

#### 数据存储和查询

数据库功能大致分为存储管理器和查询处理部件。其中查询处理器包括DDL解释器（解释DDL语句并将这些定义记录在数据字典中）和DML编译器（将查询语言中的DML语句翻译为低级指令）。

#### 事务管理

将数据库几个操作合起来形成一个逻辑单元，事务要求原子性、一致性、持久性，例如资金转账必须保证一扣一加。

#### 数据库体系结构

数据库用户使用客户机client，运行数据库系统为服务器server。client上的ODBC或者JDBC这种应用程序接口标准用于进行C-S之间交互。

#### 数据挖掘与信息检索

数据挖掘data mining，即从数据中寻找规则或模式，例如年收入高于50000的人更有可能买车。

信息检索：查询非结构化的文本。

#### 特种数据库

某些应用领域有特殊关系限制，因此会开发基于对象的具有不同数据模型的数据库。

* 面向对象的数据模型
* 半结构化数据模型

#### 数据库用户和管理员

#### 数据库系统历史

# Par1 关系数据库

## 第2章——关系模型介绍

#### 关系数据库结构

关系数据库由表的集合组成。

![image](https://user-images.githubusercontent.com/88172940/207632658-ca710eef-26c1-4fdf-bef9-fc76b774d2e8.png)

表是什么呢？先来看上述表，第一行`10101 Srinivasan Comp.Sci 65000`展示了`Srinivasan`教师的诸多信息，这一行将4个数据建立了关系。因此，表实际上某种关系集合，所以称这种数据库为关系数据库。

**关系relation——表**

**元组tuple——行**

**属性attribute——列**

每一个属性必须在某个域（数据类型）中，且具有原子性。

空值null是一种特殊的值，表未知或不存在，null会带来较多麻烦，应尽量避免。

#### 数据库模式

数据库模式database schema——数据库的逻辑设计。

数据库实例database instance——给定时刻数据库中数据的快照。

关系模式，例如对于department关系，该关系的模式是：`department(dept_name, building, budget)`

#### 码

必须要引入一个东西来区分元组（行），最好是某个属性（列）。

**超码superkey：**多个属性的集合能够区分元组。最小超码称为**候选码**。

**主码primary key：**设计者选定的候选码（候选码可能有多个）。

**外码foreign key：** 关系r1中某个属性是关系r2的主码，则这个属性在r1上称为参照r2的外码。

#### 关系运算

施加于单个或一对关系上，返回单个关系。

自然连接。

## 第3章——SQL

#### source 命令打开文件失败解决

* 一定要是英文路径。
* 先cd到目标目录，比如`cd /var/lib/mysql-files/`，然后`mysql -u root -p`进入mysql模式，然后直接`source test.sql`即可。

#### SQL查询语言概览

SQL语言有以下几个部分：

* DDL data-definition Language.
* DML data-Manipulation language.
* 完整性 integrity，保证更新不能破坏完整性约束。
* 视图定义 view definition，包含定义视图的命令。
* 事务控制 transaction control，定义事务的开始和结束的命令。
* 嵌入式SQL，用于嵌入到通用编程语言中。
* 授权 authorization，对关系和视图的授权。

#### SQL数据定义

特殊的如：`numeric(p, d) p位数字，d位小数点后位数。`

每个类型都支持null。

`char(10)`如果只填入`abc`三个字符，则会自动补7个空格，`varchar(10)`这种情况则不会补。

`nvarchar`存放使用Unicode表示的多语言数据。

#### SQL查询的基本结构

查询有三个基本子句构成：`select、from、where`。

重点我们来关注多关系查询。

```sql
mysql> select name, instructor.dept_name, building 
    -> from instructor, department
    -> where instructor.dept_name = department.dept_name;
```

![image](https://user-images.githubusercontent.com/88172940/207884021-da6e803d-a10d-4f6c-a923-11aaa65928ad.png)

显然，这句话的作用是筛选每个讲师的院系名字，且保证院系名字必须是合格的。

来细细拆解一下，首先，`instructor`表和`teaches`表如下：

![](https://user-images.githubusercontent.com/88172940/207886736-e27d96b9-2757-433a-b914-da201e722473.png)

尽管子句顺序是`select、from、where`，但是实际上我们应该按照`from、where、select`的顺序来理解。`from`子句实际上定义了该子句所列出的关系上的笛卡儿积（对应到例子中是`instruct和teaches`），例子过程如下：

```sql
for each 元组t1 in instructor
	for each 元组t2 in teaches
```

如例子而言，则产生了12 * 15 = 180个对，如下图：

![image-20221215223346451](/home/hhm/.config/Typora/typora-user-images/image-20221215223346451.png)

这其中有不少是相互没有关联的，`where`就是进行遮掩通过的筛选。

例如，可以使用下面语句筛选出教授了课程的教师：

```sql
mysql> select name, course_id 
    -> from instructor, teaches
    -> where instructor.ID = teaches.ID;
```

![image](https://user-images.githubusercontent.com/88172940/207888148-5a6a8eca-f4f9-4350-8f33-6210889bbce5.png)

~~看来非常多混子老师哇。~~

#### 自然连接

`nature join`作用于两个关系，返回一个关系，是指两个关系中具有相同名称的属性，也就是说，自动筛选出共有属性相等的笛卡儿积。

```sql
mysql> select name, course_id 
    -> from instructor, teaches
    -> where instructor.ID = teaches.ID;
```

上述可以用自然连接简洁写成：

```sql
mysql> select name, course_id
    -> from instructor natural join teaches;
```

#### 附加的基本运算

* `like`操作符实现模式匹配
  * %：匹配任意子串。
  * _：匹配任意一个字符。

* `order by`实现排序

  `desc`表示降序，`asc`表示升序。

  ```sql
  mysql> select * from instructor
      -> order by salary desc,
      -> name asc;
  ```

#### 集合运算

使用`union、intersect、except`来表示并、交、补。

* 在2009年秋季学期开设的所有课程的集合

```sql
select course_id from section where semester = 'Fall' and year = 2009;
```

* 在2010年春季学期开设的所有课程的集合

```sql
select course_id from section where semester = 'Spring' and year = 2010;
```

2009年秋季或者2010年春季，或者两个学期都开课：

```sql
(select course_id from section where semester = 'Fall' and year = 2009)
union
(select course_id from section where semester = 'Spring' and year = 2010);
```

#### 聚集函数

聚集函数是以值的一个集合为输入，返回单个值的函数。

* avg
* min
* max
* sum
* count

`select avg(salary) as avg_salary from instructor where dept_name = 'Comp.Sci';`

#### 分组聚集

对于某一个或多个属性，构造分组。

```sql
select dept_name, avg(salary) as avg_salary
from instructor
group by dept_name;
```

#### 嵌套子查询

查询在2009年秋季和2010年春季都开课了课程：

```sql
select distinct course_id from section where semester = 'Fall' and year = 2009
and 
course_id in (select course_id from section where semester = 'Spring' and year = 2010);
```

不在则可以使用`not in`。

#### with子句

使用嵌套子查询虽然非常符合自然逻辑，但是会使得代码变得晦涩。with可以临时定义关系。

查询所有工资总额大于所有系平均工资总额的系：

**下面例子没看懂，后续补。**

```sql
with dept_total (dept_name, value) as 
	(select dept_name, sum(salary) from instructor group by dept_name)
	
select dept_name
from dept_total, dept_total_avg
where dept_total.value >= dept_total_avg.value;
```

#### 数据库的修改

`delete from r where P;`从关系r中删除元组p。

删除`instructor`关系所有元组：`delete from instructor;`

删除工资为13000-15000美元的教师：`delete from instructor where salary between 13000 and 15000;`

#### 插入数据

通用：`insert into course values('CS-437', 'db', 'Comp.Sci', 4);`

完整：`insert into course (course_id, title, dept_name, credits) values('CS-437', 'db', 'Comp.Sci', 4);`

#### 更新数据

所有教师工资增长5%：`update instructor set salary = salary * 1.05;`

## 第4章——中级SQL

#### on条件

实际上`on`条件和`natural join`类似，下面的查询是等价的：

`select * from student, takes where student.ID = takes.ID;`

`select * from student join takes on student.ID = takes.ID;`

`select * from student natural join takes;`

#### 外连接

假设我们想显示一个所有学生的列表，显示他们的ID、name、dept_name、tot_cred，以及他们所选修的课程，第一反应是使用`select * from student natural join takes;`。

但是这种情况忽略了没有选课的学生。

来看两个例子：

![image](https://user-images.githubusercontent.com/88172940/208014967-b4df80a9-b53a-4d64-bc13-77be6185ba1c.png)

注意学生`Snow`，他没有选修课程，那么当使用自然连接时，就会在结果中**丢失**。而为了保证不丢失，可以在连接结果中加入一个元组，来自`student`关系中的属性被设置为学生`Snow`的相应值，而`takes`关系属性的值则被设为null。

* 左外连接：保留出现在左外连接左边关系中的元组。
* 右外连接：保留出现在右外连接右边关系中的元组。
* 全外连接：保留出现在两个关系中的元组。

相应的，之前学习的不保留未匹配元组的连接运算被称为**内连接运算**，实际上全称为`inner join`

`select * from student natural left outer join takes;`

实现左外连接步骤如下：

1、计算出内连接的结果。

2、对于在内连接左侧关系中的任意一个与右侧关系中任何元组都不匹配的元组，向连接结果加入一个元组r。

3、r的左侧关系赋值为正常的值，右侧为null。

**全外连接**

显示‘Comp.Sci.‘系所有学生以及他们在2009年春季选修的所有课程段的列表。

```sql
select * 
from (select * from student where dept_name = 'Comp.Sci')
natural full outer join
(select * from takes where semester = 'Spring' and year = 2009);
```

#### 视图

`create view v as <query expression>;`

实际上，数据库系统存储虚表，即运行结果，且**重点**存储视图的定义本身，而不存储视图的执行结果。当视图关系出现在查询中，是用存储的查询表达式来代替视图，因此，视图关系会被重新计算。

```sql
create view physics_fall_2009_watson as
select course_id, room_number from physics_fall_2009 where building = 'Watson';
```

由于`physics_fall_2009`本身是视图，因此当使用查询时，会自动进行转换：

```sql
create view physics_fall_2009_watson as
(select course_id, room_number from
(select course, course_id, building, room_number)
from course, section where course, course_id = section.course_id
and course.dept_name = 'Physics'
and section.semester = 'Fall'
and section.yeaer = '2009')
where building = 'Watson';
```

#### 物化视图

从上面可以看出，视图必须要使用时，会重新计算一遍，这样结果才会更新。而一般来说，系统会周期性来进行物化视图更新。并且加上一些权重，来优先更新某些重要或者更加频繁的视图。

#### 视图更新

视图表达更新、插入、删除会带来严重的问题。一般采用来那个两种方式来解决这个问题：

* 拒绝插入（大部分采用）。
* 翻译视图插入语句之后，插入到正确的表中。

#### 事务transaction

事务是由查询和更新语句的序列组成，当一条SQL语句被执行，就隐式开始了一个事务。下面SQL语句之一会结束一个事务。

* commit work：提交当前事务，将该事务的更新在数据库中持久保存。然后一个新的事务正式开始。
* Rollback work：回滚当前事务，撤销该事务中所有SQL语句对数据库的更新，恢复到上一个事务的状态。

#### 完整性约束

保证修改不会破坏数据的一致性。主要约束有：

* `not null`：禁止空值。
* `unique`：声明形成一个候选码(`unique(A1, A2, ... ,A3)`)
* `check`：保证属性值满足制定的条件，类似于自己规定域。

```sql
create table section
(
    course_id	varchar(8),
    semester	varchar(8),
    check (semester in ('Fall'. 'Winter'. 'Spring'. 'Summer'))
);
```

#### 参照完整性

参照完整性约束：referential-intergrity constraint

默认情况下，SQL外码参照的是被参照表中的主码属性，但是我们也可以使用`references`子句来指定参照属性。

声明该属性为外码：`dept_name varchar(20) references department`。

定义外键：`foreign key (building, room_number) references classroom`

#### SQL的数据类型和模式

* data：'2001-04-25'
* time：'09:30:00'
* timesstamp：'2001-04-25 10:29:01.45'

* current_date：返回当前日期
* current_time：返回当前时间（带有时区）
* default()，指定默认值。`tot_cred numeric(3, 0) default 0.`

#### 创建索引

事实上，许多查询只涉及了数据库中少量的数据，如果每次都遍历整个表，这是非常低效的。因此引入了索引。

索引index是一种数据结构，允许数据库系统高效地找到关系中那些在索引属性上给定值的元组，而不是扫描关系中的所有元组。例如，我们在`student`关系的属性id上创建了index，那么数据库系统就不用读取student关系中所有元组，就可以直接找到任何像22201或44553这样具有指定id值的记录。

在ID上创建索引：`create index studentID-index on student(ID);`

底层上索引是使用B+树实现的。

#### 大对象类型

对于某些很大的数据，SQL提供字符数据大对象数据类型（clob）和二进制数据的大对象数据类型（blob）。

```sql
book_review clob(10KB)
image blob(10MB)
movie blob(2GB)
```

通常使用一个定位器定位大数据的存在，而不是直接遍历。

#### create table的拓展

当我们被要求创建与现有某个表模式相同的表时，可以使用如下命令：

`create table tmp_instructor like instructor;`

书写一个复杂查询，将查询结果存储为一个新表：

```sql
create table tl as
(select * from instructor where dept_name = 'Music')
with data;
```

#### 模式、目录与环境

早期文件系统是平面结构，即所有的文件都在同一个目录下。当代数据库系统提供了三层结构的关系命名机制，最上层是目录（catalog），每个目录都可以包含模式（schema），诸如关系和视图这样的SQL对象都包含在模式中。

**实际上，很多数据库喜欢用术语“数据库”来代替术语”目录“。**

用户（**或程序**）必须通过用户名和密码连接数据库系统，连接时，系统会为用户设置好默认的目录和模式。

为了唯一标识出一个关系，必须使用一个名字，包含三部分，例如：`catalog7.univ_schema.course`。当名字的目录是连接的默认目录时，可以省略目录部分。即可以使用`univ_schema.course`

如果这个模式是默认模式，那也可以省略模式的名字，即`course`即可唯一标识一个目录。

**可以创建多个目录——实现了多用户和多应用共用一个数据库系统。** 

**一个目录可以创建多个模式——实现了多版本（一个产品版本、一个测试版本）。**

#### 授权





```sql
//  数据库课设建表
create
database db;
use
db

create table thesis
(
    thesis_no    varchar(10) not null,
    thesis_name  nvarchar(50) not null,
    thesis_pub   nvarchar(50) not null,
    thesis_state int         not null,
    thesis_date  date        not null,
    thesis_index varchar(10) not null,
    thesis_bel   nvarchar(20) not null,
    thesis_scan  text,
    thesis_pdf   text,

    primary key (thesis_no)
);

create table phd_reward
(
    reward_no       varchar(10) not null,
    reward_name     nvarchar(50) not null,
    reward_rank     nvarchar(10) not null,
    reward_score    nvarchar(10) not null,
    reward_order    int         not null,
    reward_date     date        not null,
    reward_identity text,

    primary key (reward_no)
);

create table standard
(
    standard_no       varchar(10) not null,
    standard_name     nvarchar(20) not null,
    standard_rank     nvarchar(10) not null,
    standard_date     date        not null,
    standard_identity text,

    primary key (standard_no)
);

create table phd_other
(
    other_no       varchar(10) not null,
    other_name     nvarchar(20) not null,
    other_rank     nvarchar(20) not null,
    other_date     date        not null,
    other_identity text,

    primary key (other_no)
);

create table mas_book
(
    book_no         varchar(10) not null,
    book_name       nvarchar(20) not null,
    book_publisher  nvarchar(50) not null,
    book_date       date        not null,
    book_distribute int         not null,
    book_identity   text,

    primary key (book_no)
);

create table mas_patent
(
    patent_no       varchar(10) not null,
    patent_name     nvarchar(20) not null,
    patent_type     nvarchar(20) not null,
    patent_state    int         not null,
    patent_time     nvarchar(20) not null,
    patent_con      int         not null,
    patent_identity text,

    primary key (patent_no)
);

create table mas_report
(
    report_no       varchar(10) not null,
    report_name     nvarchar(20) not null,
    report_type     nvarchar(20) not null,
    report_unit     nvarchar(20) not null,
    report_date     date        not null,
    report_con      int         not null,
    report_identity text,

    primary key (report_no)
);

create table mas_soft_hard
(
    soft_hard_no       varchar(10) not null,
    soft_hard_name     nvarchar(20) not null,
    soft_hard_unit     nvarchar(50) not null,
    soft_hard_date     date        not null,
    soft_hard_con      int         not null,
    soft_hard_identify text,

    primary key (soft_hard_no)
);

create table manager_info
(
    man_id   varchar(10) not null,
    man_name nvarchar(10) not null,
    man_tel  nvarchar(20) not null,
    user     nvarchar(20) not null,
    pwd      nvarchar(20) not null,

    primary key (man_id)
);


create table teacher_info
(
    tea_id     varchar(10) not null,
    tea_name   nvarchar(10) not null,
    college    nvarchar(10) not null,
    dept       nvarchar(20) not null,
    title      nvarchar(10) not null,
    is_duty    int         not null,
    is_tutor   int         not null,
    is_lecture int         not null,
    user       nvarchar(20) not null,
    pwd        nvarchar(20) not null,

    primary key (tea_id)
);



create table course_info
(
    crs_no    varchar(10)   not null,
    crs_name  varchar(10)   not null,
    crs_num   int           not null,
    crs_time  int           not null,
    crs_score decimal(4, 2) not null,

    primary key (crs_no)
);


create table graduate_info
(
    gra_id   varchar(10) not null,
    gra_name nvarchar(10) not null,
    gra_type int         not null,
    gra_coll nvarchar(10) not null,
    dept     nvarchar(20) not null,
    tea_id   varchar(10) not null,
    user     varchar(10) not null,
    pwd      nvarchar(10) not null,

    primary key (gra_id),
    foreign key (tea_id) references teacher_info (tea_id)
);

create table assistant_evaluate
(
    ae_no    varchar(10) not null,
    gra_id   varchar(10) not null,
    crs_no   varchar(10) not null,
    stu_num  int,
    crs_nat  int         not null,
    crs_stu  int         not null,
    tea_id   varchar(10) not null,
    ass_time date,
    self_eva text        not null,
    tea_eva  text        not null,
    ae_res   int         not null,
    ae_time  date        not null,

    primary key (ae_no),
    foreign key (gra_id) references graduate_info (gra_id),
    foreign key (crs_no) references course_info (crs_no),
    foreign key (tea_id) references teacher_info (tea_id)
);

create table academic_exchange
(
    ace_no     varchar(10) not null,
    gra_id     varchar(10) not null,
    ace_name   nvarchar(50) not null,
    ace_place  nvarchar(50) not null,
    ace_date   date        not null,
    ace_CHname nvarchar(100) not null,
    ace_ENname nvarchar(100) not null,
    ace_pic    text,
    ace_note   text,

    primary key (ace_no),
    foreign key (gra_id) references graduate_info (gra_id)
);

create table participation_projects
(
    pp_no       varchar(10)   not null,
    gra_id      varchar(10)   not null,
    proj_id     varchar(10)   not null,
    proj_class  nvarchar(50) not null,
    proj_name   nvarchar(100) not null,
    proj_begin  date          not null,
    proj_end    date          not null,
    duty_work   text          not null,
    proj_outlay decimal(8, 2) not null,

    primary key (pp_no),
    foreign key (gra_id) references graduate_info (gra_id)
);

create table phd_achievement
(
    phd_id      varchar(10) not null,
    phd_type    int         not null,
    thesis_no   varchar(10) not null,
    reward_no   varchar(10) not null,
    standard_no varchar(10) not null,
    other_no    varchar(10) not null,

    primary key (phd_id),
    foreign key (thesis_no) references thesis (thesis_no),
    foreign key (reward_no) references phd_reward (reward_no),
    foreign key (standard_no) references standard (standard_no),
    foreign key (other_no) references phd_other (other_no)
);

create table mas_achievement
(
    mas_id       varchar(10) not null,
    mas_type     int         not null,
    thesis_no    varchar(10) not null,
    book_no      varchar(10) not null,
    standard_no  varchar(10) not null,
    report_no    varchar(10) not null,
    patent_no    varchar(10) not null,
    soft_hard_no varchar(10) not null,

    primary key (mas_id),
    foreign key (thesis_no) references thesis (thesis_no),
    foreign key (book_no) references mas_book (book_no),
    foreign key (standard_no) references standard (standard_no),
    foreign key (report_no) references mas_report (report_no),
    foreign key (patent_no) references mas_patent (patent_no),
    foreign key (soft_hard_no) references mas_soft_hard (soft_hard_no)
);
```



## [下载链接](https://www.aliyundrive.com/s/mX5PTuhGWsx)

提前声明：不能用于商业用途，仅供学习。